"""weiner attack for relatively small d::
when, p<q<2p; e<n and d is of the order n**0.25
check when e is not 3 or 65537
"""
from fractions import Fraction
import math
from sympy import solve,Symbol

def cont_fractions(a):
	real=a
	cont_frac=[]

	while True:
		integer=math.trunc(real)
		cont_frac.append(integer)
		fraction=real-integer
		if fraction==0:
			break
		real=1/fraction

	return cont_frac[::-1]


def approximation(e,n):
	init=Fraction(e,n)
	rev=cont_fractions(init)  #getting the reversed the array of continued fractions
	length=len(rev)
	approx=[]

	for x in range(length):
		
		try:
			frac=Fraction(1,rev[0])
		except:
			#approx.append(Fraction(0,1)) -- not appending zero since its unnecessary
			break

		j=1	
		while j<len(rev):
			cont=rev[j]+frac
			frac=1/cont
			j+=1

		rev=rev[1:] #removing first element to decrease approximation accuracy
		approx.append(1/frac)

	return approx[::-1]

def p_q(e,n):   #for returning the factors
	approx=approximation(e,n)

	m=12345
	c=pow(m,e,n) #checking d by using simple example

	for x in range(len(approx)):
		k=approx[x].numerator
		d=approx[x].denominator
		
		m0=pow(c,d,n)
		if m==m0:
			phi=(e*d-1)//k #major error occurs if we put a single '/'
			x=Symbol('x')
			sol=solve(x**2-(n-phi+1)*x+n,x)  #solving quadratic for p,q
			return int(sol[0]),int(sol[1]),d,phi
			break

#e=2734411677251148030723138005716109733838866545375527602018255159319631026653190783670493107936401603981429171880504360560494771017246468702902647370954220312452541342858747590576273775107870450853533717116684326976263006435733382045807971890762018747729574021057430331778033982359184838159747331236538501849965329264774927607570410347019418407451937875684373454982306923178403161216817237890962651214718831954215200637651103907209347900857824722653217179548148145687181377220544864521808230122730967452981435355334932104265488075777638608041325256776275200067541533022527964743478554948792578057708522350812154888097 
#n=21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771
#phi=21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280249307490374900729021320924716697863966277266625488626020771604596923670543560857724741855180400786259195735908618899535592322919617065525626834782656528352786625383923291590279348919015437292702452668873586799771898145386750557481851748649545280807708561842706253359025121644739401403945728547286791397492272 
def attack(e,n):
	p,q,d,tot=p_q(e,n)

	print("p:",p)
	print("q:",q)
	print("\ntotient:",tot)
	print("private key d:",d)


	return d

#print(attack(e,n))
#print(approximation())



#add condition to stop add more conditional factors if d>1/3*(n^0.25)
#check whether examples have n and e have same no. of bits